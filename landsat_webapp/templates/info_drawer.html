<!-- info_drawer.html -->
<div class="offcanvas offcanvas-end" tabindex="-1" id="infoDrawer" aria-labelledby="infoDrawerLabel">
    <div class="offcanvas-header">
        <h3 class="offcanvas-title" id="infoDrawerLabel">Info</h3>
        <button type="button" class="btn-close text-reset" data-bs-dismiss="offcanvas" aria-label="Close"></button>
    </div>
    <div class="offcanvas-body" id="infoDrawerContent">
        <!-- Content will be dynamically inserted here -->
    </div>
</div>

<script>
    function openInfoDrawer(data) {
        // Store data globally for access in the drawer
        window.drawerData = {
            lng: data.lng,
            lat: data.lat
        };

        // Prepare the content for the drawer, divided into three sections
        const drawerContent = `
            <!-- Section 1: General Info -->
            <div class="drawer-section" id="general-info-section">
                <h5>General Info</h5>
                <p>Longitude: ${data.lng}<br>Latitude: ${data.lat}</p>
            </div>

            <hr>
            <!-- Section 2: Passover Predictions and Cloud Coverage -->
            <div class="drawer-section" id="predictions-section">
                <h5>Passover Predictions of Landsat</h5>
                <div class="mb-3">
                    <label for="date-input" class="form-label">Select Date:</label>
                    <input type="date" id="date-input" class="form-control" min="${getCurrentDateString()}" max="${getOneMonthLaterDateString()}">
                </div>
                <button id="fetch-predictions-btn" class="btn btn-primary mb-3">Fetch Predictions</button>
                <div id="predictions-content"></div>

                <hr>
                <h5>Cloud Coverage</h5>
                <div class="form-check mb-3">
                    <input class="form-check-input" type="checkbox" id="enable-cloud-coverage">
                    <label class="form-check-label" for="enable-cloud-coverage">Enable Cloud Coverage</label>
                </div>

                <!-- Collapsible Cloud Coverage Section -->
                <div id="cloud-coverage-section" class="collapse">
                    <div class="mb-3">
                        <label for="slider" class="form-label">Cloud Coverage</label>
                        <input type="range" id="slider" class="form-range" min="0" max="100" value="50">
                        <span id="slider-value">50%</span>
                    </div>

                    <div class="mb-3">
                        <label for="start-date" class="form-label">From:</label>
                        <input type="date" id="start-date" class="form-control">
                    </div>
                    <div class="mb-3">
                        <label for="end-date" class="form-label">To:</label>
                        <input type="date" id="end-date" class="form-control">
                    </div>
                    <button id="fetch-metadata-btn" class="btn btn-primary mb-3">Fetch Metadata</button>
                    <div id="metadata-content"></div>
                </div>
            </div>

            <!-- Section 3: Placeholder -->
            <hr>
            <div class="drawer-section" id="placeholder-section">
                <h5>Additional Information</h5>
                <p>Content coming soon...</p>
            </div>
        `;

        // Set the content of the drawer
        document.getElementById('infoDrawerContent').innerHTML = drawerContent;

        // Initialize the date inputs
        document.getElementById('start-date').value = getOneMonthEarlierDateString();
        document.getElementById('end-date').value = getCurrentDateString();
        document.getElementById('start-date').max = getCurrentDateString();
        document.getElementById('end-date').max = getCurrentDateString();

        // Show the drawer
        const infoDrawer = new bootstrap.Offcanvas(document.getElementById('infoDrawer'));
        infoDrawer.show();

        // Attach event listeners
        attachEventListeners();
    }

    function attachEventListeners() {
        // Enable or disable the collapse for cloud coverage section based on checkbox
        const enableCloudCoverage = document.getElementById('enable-cloud-coverage');
        enableCloudCoverage.addEventListener('change', (event) => {
            const isEnabled = event.target.checked;
            const cloudCoverageSection = document.getElementById('cloud-coverage-section');

            if (isEnabled) {
                // Show the cloud coverage section
                new bootstrap.Collapse(cloudCoverageSection, {
                    show: true
                });
            } else {
                // Hide the cloud coverage section
                new bootstrap.Collapse(cloudCoverageSection, {
                    hide: true
                });
            }
        });

        // Update slider value display
        const slider = document.getElementById('slider');
        const sliderValue = document.getElementById('slider-value');
        slider.addEventListener('input', (event) => {
            sliderValue.textContent = `${event.target.value}%`;
        });

        // Handle date inputs
        const startDateInput = document.getElementById('start-date');
        const endDateInput = document.getElementById('end-date');

        // Ensure "To" date does not exceed today and "From" date does not exceed "To" date
        endDateInput.addEventListener('input', () => {
            startDateInput.max = endDateInput.value;
        });

        // Ensure "From" date does not exceed "To" date
        startDateInput.addEventListener('input', () => {
            endDateInput.min = startDateInput.value;
        });

        // Fetch predictions
        const fetchButton = document.getElementById('fetch-predictions-btn');
        fetchButton.addEventListener('click', fetchPredictions);

        // Fetch metadata
        const fetchMetadataButton = document.getElementById('fetch-metadata-btn');
        fetchMetadataButton.addEventListener('click', fetchMetadata);
    }

    function getCurrentDateString() {
        const today = new Date();
        return today.toISOString().split('T')[0]; // yyyy-mm-dd
    }

    function getOneMonthLaterDateString() {
        const today = new Date();
        today.setMonth(today.getMonth() + 1);
        return today.toISOString().split('T')[0];
    }

    function getOneMonthEarlierDateString() {
        const today = new Date();
        today.setMonth(today.getMonth() - 1);
        return today.toISOString().split('T')[0];
    }

    let fetchingInterval;

    function startFetchingAnimation(contentElement) {
        let dots = '';
        fetchingInterval = setInterval(() => {
            if (dots.length < 3) {
                dots += '.';
            } else {
                dots = '';
            }
            contentElement.innerHTML = `<p>Fetching${dots}</p>`;
        }, 500); // Update every 500 milliseconds
    }

    function stopFetchingAnimation() {
        clearInterval(fetchingInterval);
    }

    function fetchPredictions() {
        const dateInput = document.getElementById('date-input').value;
        if (!dateInput) {
            alert('Please select a date.');
            return;
        }

        const selectedDate = new Date(dateInput);
        const today = new Date();
        const timeDiff = selectedDate - today;
        const daysAhead = Math.ceil(timeDiff / (1000 * 60 * 60 * 24)); // Convert milliseconds to days

        if (daysAhead < 0 || daysAhead > 32) {
            alert('Please select a date within the next month.');
            return;
        }

        const { lng, lat } = window.drawerData;

        // Start the fetching animation
        const predictionsContent = document.getElementById('predictions-content');
        startFetchingAnimation(predictionsContent);

        // Call the predict endpoint
        fetch(`/predict?lat=${lat}&lon=${lng}&days=${daysAhead}`)
            .then(response => response.json())
            .then(predictionData => {
                // Stop the fetching animation
                stopFetchingAnimation();

                displayPredictions(predictionData);
            })
            .catch(error => {
                // Stop the fetching animation
                stopFetchingAnimation();

                console.error('Error fetching prediction data:', error);
                predictionsContent.innerHTML = '<p>Error fetching prediction data.</p>';
            });
    }

    function fetchMetadata() {
        const { lng, lat } = window.drawerData;
        const cloudCoverage = document.getElementById('slider').value;
        const startDate = document.getElementById('start-date').value;
        const endDate = document.getElementById('end-date').value;

        // Start the fetching animation
        const metadataContent = document.getElementById('metadata-content');
        startFetchingAnimation(metadataContent);

        // Call the metadata endpoint
        fetch(`/metadata?lat=${lat}&lon=${lng}&cloud_coverage=${cloudCoverage}&start_date=${startDate}&end_date=${endDate}`)
            .then(response => response.json())
            .then(metadata => {
                // Stop the fetching animation
                stopFetchingAnimation();

                displayMetadata(metadata);
            })
            .catch(error => {
                // Stop the fetching animation
                stopFetchingAnimation();

                console.error('Error fetching metadata:', error);
                metadataContent.innerHTML = '<p>Error fetching metadata.</p>';
            });
    }

    function displayPredictions(predictionData) {
        const predictionsContent = document.getElementById('predictions-content');
        if (!predictionData || Object.keys(predictionData).length === 0) {
            predictionsContent.innerHTML = '<p>No predictions available for the selected date.</p>';
            return;
        }

        let content = '';
        for (const satellite in predictionData) {
            const times = predictionData[satellite];
            content += `<h6>${satellite}:</h6><ul>`;
            times.forEach(time => {
                const formattedTime = formatDateTime(time);
                content += `<li>${formattedTime}</li>`;
            });
            content += '</ul>';
        }

        predictionsContent.innerHTML = content;
    }

    function displayMetadata(metadata) {
        const metadataContent = document.getElementById('metadata-content');
        if (!metadata) {
            metadataContent.innerHTML = '<p>No metadata available for the selected criteria.</p>';
            return;
        }

        let content = '<h6>Metadata:</h6>';
        for (const key in metadata) {
            content += `<p><strong>${key}:</strong> ${metadata[key]}</p>`;
        }

        metadataContent.innerHTML = content;
    }

    function formatDateTime(utcString) {
        const date = new Date(utcString);
        const options = {
            year: 'numeric',
            month: '2-digit',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
            hour12: false,
            timeZoneName: 'short'
        };
        const localeString = date.toLocaleString(undefined, options);
        const [datePart, timePartWithZone] = localeString.split(', ');
        const [timePart, timeZone] = timePartWithZone.split(' ');
        const [month, day, year] = datePart.split('/');
        const formattedDate = `${month}-${day}-${year}`;
        return `${formattedDate} @ ${timePart} ${timeZone}`;
    }
</script>
